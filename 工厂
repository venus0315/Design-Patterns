依赖倒置原则：要依赖抽象，不要依赖具体类。
 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。而且也尽量不要覆盖基类实现的方法，否则一旦抽象类中实现方法改变，则覆盖了父类方法的子类也需要改变。而且基类中已实现的方法应该由所有子类共享。
 
 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。


在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。

在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。



简单工厂， 工厂方法模式， 抽象工厂模式：

简单工厂:
简单工厂不是一个模式，而是一种编程习惯。

工厂方法模式：
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。适合 初始化工作复杂，可能要读取配置文件等，导致代码过长，
如果将他们都写在构造函数中，会导致构造函数过大，不利于代码的修改与维护。
可能会有其他的多种替换方案。



工厂方法的子类看起来很像简单工厂，
但是简单工厂把全部的事情，在一个地方都处理完了， 然而工厂方法却是创建一个框架，让子类决定要如何实现。
使用接口让代码富有弹性， 但是还是要建立具体类的实例。
Drink drink =new CocoColar();

我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。

FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。






策略模式：









