# Design-Patterns
模式：

是在某情境下，针对某问题的某种解决方案。


设计模式：

设计模式告诉我们如何组织类和对象以解决某种问题。
库与框架长久以来，一直扮演着软件开发过程的重要角色，我们从中挑选所要的组件，把他们放进合适的地方，
但是库与框架无法帮助我们将应用组织成容易理解，容易维护，具有弹性的架构，所以需要设计模式。


模式分类：

基本的模式：《设计模式：可复用面向对象软件的基础》的23个基本的模式。
其他模式： 专注于企业软件，并发系统，业务系统等。


23个基本的模式分类:

1.根据模式的目标分成三个不同类目:

创建型：涉及到将对象实例化，这类模式提供一个方法，将客户从所需要实例化的对象中解耦。

singleton(单例模式）, abstractFactory抽象工厂模式, factoryMethod工厂方法 (prototype, builder)

行为型：涉及到类和对象如何交互分配职责。

Template Method（模板方法）, Iterator（迭代器模式）, Command（命令模式）, Observer（观察者模式),
State（状态模式）, Strategy（策略模式） (visitor, Mediator, Interpreter, Chain of Responsibility, Memento)

结构型：可以把类或对象组合到更大的结构中。

Decorator（装饰者模式）,Proxy（代理模式）,Facade(外观模式）,Composite(组合模式）,Adapter(适配器模式）（Bridge, Flyweight)

2.根据模式所处理的是类或对象：

类 :

template Method,Factory Method, Adapter, (Interpreter)

对象：

Singleton(单例模式）, abstractFactory抽象工厂模式,  Iterator（迭代器模式）, Command（命令模式）,
Observer（观察者模式）, State（状态模式）, Strategy（策略模式）Decorator（装饰者模式）,Proxy（代理模式）,
Facade(外观模式）,Composite(组合模式）,Adapter(适配器模式）  (prototype, builder，visitor, Mediator, Chain of Responsibility, Memento，Bridge, Flyweight)



共享模式：

模式能够用更少的词汇座更充分的沟通。
将说话的方式保持在模式层次，可以减少琐碎的事情。
共享词汇可以帮住开发团队快速充电。
共享词汇帮助初级开发人员迅速成长。



OO基础：
抽象，封装，多态，继承。







设计原则 ：
一：封装变化：
找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。
-->结果：代码变化引起的不经意后果变少，系统变得有弹性。

二：
针对接口编程，而不是针对实现编程。（针对接口编程的真正意思是：针对超类型编程。）
--》

三：
多用组合，少用继承。
使用组合建立系统具有很大的弹性，不仅可以将算法簇封装成类，更可以在运行时动态的改变行为，只要组合的行为对象符合正确的接口标准即可。

四：为交互对象之间的松耦合设计而努力。

五：开闭原则：对扩展开放，对修改关闭。即应尽量在不修改原有代码的情况下进行扩展。
为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。

六：依赖抽象，不要依赖具体类。 --依赖倒置--抽象方法
依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
避免违反依赖倒置的原则的方法：
变量不可以持有具体类的引用
不要让类派生自具体类。
不要覆盖基类中已经实现的方法。

七：只和朋友交谈。迪米特法则(Law of  Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。对于一个对象，其朋友包括以下几类：
  (1) 当前对象本身(this)；
  (2) 以参数形式传入到当前对象方法中的对象；
  (3) 当前对象的成员对象；
  (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
  (5) 当前对象所创建的对象。
      
      
      
八:别找我，我会找你。

九：单一职责原则：一个类只负责一个功能领域中的相应职责， 换句话说就是，类应该只有一个改变的理由。
单一职责原则是实现高内聚、低耦合的指导方针。将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。

里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。里氏代换原则是实现开闭原则的重要方式之一。在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类

依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
接口隔离原则
